import { defaultStylesInjectOptions } from 'css-es-modules';
import { readFileSync } from 'fs';
import { dirname, join, relative } from 'path';
import postcss, { Builder, Root, Node } from 'postcss';
import { v4 } from 'uuid';
import { defaultOptions, ExtendedStylesInjectOptions, Options } from './options';

/**
 * Options for runtime type.
 */
type RuntimeOptions = Pick<ExtendedStylesInjectOptions, typeof runtimeOptionsKeys[number]>;

/**
 * Keys of runtime options.
 */
const runtimeOptionsKeys =
    ['useNounce', 'useConstructableStylesheet', 'useStyleTag', 'useNodeGlobal'] as const;

/**
 * Preparing runtime options
 */
const prepareRuntimeOptions = (options: Required<Options>): RuntimeOptions | undefined => {
    const loaderOptions = options.loader;
    let runtimeOptions: RuntimeOptions | undefined;
    if (loaderOptions) {
        let hasModifiedOptions = false;
        runtimeOptions = runtimeOptionsKeys.reduce((r, i) => {
            if (loaderOptions[i] !== defaultStylesInjectOptions[i]) {
                hasModifiedOptions = true;
                return {
                    ...r,
                    [i]: loaderOptions[i]
                }
            }
            return r;
        }, {} as RuntimeOptions);
        if (! hasModifiedOptions) {
            runtimeOptions = undefined;
        }
    }
    return runtimeOptions;
}


/**
 * Builds import statement.
 */
const buildImportStatement = (
    node: Root, builder: Builder, from: string, item: string, module: 'esm' | 'cjs' = defaultOptions.loader.moduleType) => {
    if (module === 'esm') {
        builder(`import { ${item} } from '${from}';\n`, node);
    } else if (module === 'cjs') {
        builder(`const { injectStyles } = require(${from});\n`, node);
    }
}

/**
 * Builds import statement of injector.
 */
const buildImportInjectStylesStatement = (
    node: Root, builder: Builder, options: ExtendedStylesInjectOptions = {}) => {
    if (options.script === 'eject'
        && options.scriptEjectPath
        && node.source?.input.file) {
        let rel = relative(dirname(node.source.input.file), options.scriptEjectPath);
        rel = rel.replace(/\\/g, '/');
        if (!rel.startsWith('.')) {
            rel = `./${rel}`
        }
        buildImportStatement(node, builder, `${rel}/inject-styles`, 'injectStyles', options.moduleType);
    } else {
        buildImportStatement(node, builder, 'css-es-modules', 'injectStyles', options.moduleType);
    }
}

const readCodeForEmbed = (
    scriptType: ExtendedStylesInjectOptions['scriptType'],
    moduleType: ExtendedStylesInjectOptions['moduleType']): string => {
    const codeBasePath = require.resolve('css-es-modules');
    const codePath = scriptType === 'ts'
        ? join(codeBasePath, '../../../src/inject-styles.ts')
        : moduleType === 'esm'
            ? join(codeBasePath, '../../dist-esm/inject-styles.js')
            : join(codeBasePath, '../../dist-cjs/inject-styles.js')
    const code = readFileSync(codePath).toString('utf-8');
    return `${code}\n`;
};

let embedCode: string | undefined;

export const createStringify = (options: Required<Options>) => {

    const { attachOriginalClassName } = options.modules;
    const { script, scriptType, moduleType } = options.loader;
    const runtimeOptions = prepareRuntimeOptions(options);

    return (node: Node, builder: Builder) => {
        if (node.type === 'root') {
            let classMap: Record<string, string> | undefined;
            // looking for module-map comment
            node.walkComments(comment => {
                const cmt = comment.text;
                if (cmt.startsWith('modules-map:')) {
                    classMap = JSON.parse(cmt.replace('modules-map:', ''));
                }
            });
            // we handling only roots which contains module-map
            if (classMap) {
                // generate stylesheet unique key
                const sheetKey = v4();
                // clone for removing comments, as we do not want to touch original root
                const cloned = node.clone();
                cloned.walkComments(c => c.remove());
                builder(`// File generated by the postcss-es-modules plugin. Please do not modify it !!!\n`)
                // import statement
                if (script === 'embed') {
                    if (!embedCode) {
                        embedCode = readCodeForEmbed(scriptType, moduleType);
                    }
                    builder(embedCode, node);
                } else {
                    buildImportInjectStylesStatement(cloned, builder, options.loader);
                }
                // if there are custom runtime options
                // we will add them to runtime
                if (runtimeOptions) {
                    builder(`const options = ${JSON.stringify(runtimeOptions)};\n`)
                }
                // key of stylesheet
                builder(`const key = '${sheetKey}';\n`, cloned);

                // raw css body
                builder('const css =`', cloned);
                postcss.stringify(cloned, builder);
                builder('`;\n', cloned);

                // styles object
                builder(`const styles = {\n`, cloned);
                // styles class names map
                Object.keys(classMap).forEach((className) => {
                    if (classMap?.[className]) {
                        const resolvedClassName =
                            `${classMap[className]}${attachOriginalClassName ? ` ${className}` : ''}`;
                        builder(`    get ['${className}']() { `
                            + `injectStyles(key, css${runtimeOptions ? ', options' : ''}); `
                            + `return '${resolvedClassName}'; },\n`, cloned);
                    }
                });
                // inject method
                builder(`    inject() { injectStyles(key, css${runtimeOptions ? ', options' : ''}); }\n`, cloned);
                builder(`};\n`, cloned);

                // export statement
                builder(`export default styles;\n`, cloned);

                return;
            }
        }

        // in any other case we will use default stringify
        postcss.stringify(node, builder);
    }
}
